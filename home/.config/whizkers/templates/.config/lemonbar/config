#!/usr/bin/env python
# -* coding: utf-8 -*-
# bar_conf | lemonbar -bd -g x70++20 -u 5 -f "Calibri-9" -f "M+ 1p-9"
# TODO split into modules... this is a clusterfck

from ipdb import set_trace

import i3ipc
from sys import stdout, exit
from time import sleep
from multiprocessing import Process, Lock

import json
from subprocess import check_output

ENCODING = 'utf-8'

C_BG            = '#ff272727'
C_FG            = '#fffafafa'
C_URGENT        = '#ffff0000'
C_TRANSPARENT   = '#00000000'
# C_BG        = '{{ n_black }}'
# C_FG        = '{{ fgc }}'
# C_URGENT    = '{{ b_red }}'

S_NORMAL        = "%%{B%s}%%{F%s}" % (C_BG, C_FG)
S_TRANSPARENT   = "%%{B%s}%%{F%s}" % (C_TRANSPARENT, C_TRANSPARENT)

MIN_INTERVAL  = 1
MAX_TITLE_LEN = 80


class Updater(object):
    def __init__(self, observers=[]):
        self.observers = observers

    def register_observers(self, func):
        self.observers.append(func)

    def notify_observers(self):
        for observer in self.observers:
            observer.notify()

    def query(self):
        raise NotImplementedError


class IntervalUpdater(Updater):
    def __init__(self, interval, observers=[]):
        super(IntervalUpdater, self).__init__(observers)
        self.interval = interval

    def main(self):
        while True:
            sleep(self.interval)
            self.notify_observers()


class I3Updater(Updater):
    def __init__(self, conn, observers=[]):
        super(I3Updater, self).__init__(observers)
        self.conn = conn


class WorkspaceUpdater(I3Updater):
    def __init__(self, conn, observers=[]):
        super(WorkspaceUpdater, self).__init__(conn, observers)
        self.build()
        conn.on('workspace', self.on_workspace)

    def on_workspace(self, ipc, e):
        self.build()
        self.notify_observers()

    def build(self):
        spaces_text = []
        for space in self.conn.get_workspaces():
            current = space['name'].partition(':')[-1] \
                if ':' in space['name'] \
                else space['name']

            if space['visible']:
                current = '%%{+u}%s%%{-u}' % (current)
            if space['urgent']:
                current = '%%{F%s}%s%%{F-}' % (C_URGENT, current)

            spaces_text.append(current)
        self.spaces_str = ('  '.join(spaces_text)).encode(ENCODING)

    def query(self):
        return self.spaces_str


class WindowUpdater(I3Updater):
    def __init__(self, conn, observers=[]):
        super(WindowUpdater, self).__init__(conn, observers)
        self.build()
        conn.on('window', self.on_change)
        conn.on('workspace::focus', self.on_change)

    def on_change(self, ipc, e):
        self.build()
        self.notify_observers()

    def build(self):
        name = self.conn.get_tree().find_focused().name
        self.title = (name[:MAX_TITLE_LEN] + (
            u'â€¦' if len(name) > MAX_TITLE_LEN else ''
        )).encode(ENCODING)

    def query(self):
        return self.title

class Bar:
    def __init__(self):
        self.mutex = Lock()
        i3_conn = i3ipc.Connection()

        self.interval_updater = IntervalUpdater(MIN_INTERVAL, [self])
        self.workspace_updater = WorkspaceUpdater(i3_conn, [self])
        self.window_updater = WindowUpdater(i3_conn, [self])

        self.procs = [
            Process(target=self.interval_updater.main),
            Process(target=i3_conn.main),
        ]

    def start(self):
        for proc in self.procs:
            proc.daemon = True
            proc.start()

        self.output()

    def notify(self):
        self.output()

    def output(self):
        with self.mutex:
            bar = S_TRANSPARENT

            window_update = self.window_updater.query()
            if window_update:
                bar += '%{l}' + S_NORMAL + '  ' + \
                    window_update + '  ' + S_TRANSPARENT

            workspace_update = self.workspace_updater.query()
            if workspace_update:
                bar += '%{l}' + S_NORMAL + '  ' + \
                    workspace_update + '  ' + S_TRANSPARENT

#             print(bar)
            print '%s: %s' % (self.window_updater, window_update)

            # Need this to fix buffering problem
            stdout.flush()


if __name__ == '__main__':
    Bar().start()
    try:
        while True:
            sleep(1)
    except KeyboardInterrupt:
        exit()

