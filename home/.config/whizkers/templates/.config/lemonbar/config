#!/usr/bin/env python
# -* coding: utf-8 -*-
# bar_conf | lemonbar -bd -g 3120x70+40+20 -u 5 -f "Calibri-9" -f "M+ 1p-9"
# TODO split into modules... this is a clusterfck

from ipdb import set_trace

import logging
import i3ipc
from colorlog import ColoredFormatter
from sys import stdout, stderr, exit
from time import sleep
from datetime import datetime
from threading import Thread

import json
from subprocess import check_output

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
logger.addHandler(logging.NullHandler())

ENCODING = 'utf-8'

C_BG            = '#ff272727'
C_FG            = '#fffafafa'
C_URGENT        = '#ffff0000'
C_TRANSPARENT   = '#00000000'
# C_BG        = '{{ n_black }}'
# C_FG        = '{{ fgc }}'
# C_URGENT    = '{{ b_red }}'

S_NORMAL        = '%%{B%s}%%{F%s}' % (C_BG, C_FG)
S_TRANSPARENT   = '%%{B%s}%%{F%s}' % (C_TRANSPARENT, C_TRANSPARENT)

MIN_INTERVAL  = 1
MAX_TITLE_LEN = 80


class Updater(object):
    def __init__(self, observers=[]):
        self.observers = observers

    def register_observers(self, func):
        self.observers.append(func)

    def notify_observers(self):
        for observer in self.observers:
            observer.notify()

    def query(self):
        raise NotImplementedError


class DatetimeUpdater(Updater):
    def __init__(self, interval, observers=[]):
        super(DatetimeUpdater, self).__init__(observers)
        self.interval = interval
        self.build()

    def main(self):
        while True:
            sleep(self.interval)
            self.build()
            self.notify_observers()

    def build(self):
        self.time = datetime.now().strftime('%a %b %d %H:%M')
        logger.debug('built dtm: %s' % self.time)

    def query(self):
        return self.time


class I3Updater(Updater):
    def __init__(self, conn, observers=[]):
        super(I3Updater, self).__init__(observers)
        self.conn = conn


class WorkspaceUpdater(I3Updater):
    def __init__(self, conn, observers=[]):
        super(WorkspaceUpdater, self).__init__(conn, observers)
        self.build()
        conn.on('workspace', self.on_workspace)

    def on_workspace(self, ipc, e):
        self.build()
        self.notify_observers()

    def build(self):
        spaces_text = []
        for space in self.conn.get_workspaces():
            current = space['name'].partition(':')[-1] \
                if ':' in space['name'] \
                else space['name']

            if space['visible']:
                current = '%%{+u}%s%%{-u}' % (current)
            if space['urgent']:
                current = '%%{B%s}%s%%{B-}' % (C_URGENT, current)
            current = '%%{A:i3-msg workspace "%s":}%s%%{A}' % (
                space['name'], current)

            spaces_text.append(current)
        self.spaces_str = ('  '.join(spaces_text)).encode(ENCODING)
        logger.debug('built wks: %s' % self.spaces_str)

    def query(self):
        return self.spaces_str


class WindowUpdater(I3Updater):
    def __init__(self, conn, observers=[]):
        super(WindowUpdater, self).__init__(conn, observers)
        self.build()
        conn.on('window', self.on_change)
        conn.on('workspace::focus', self.on_change)

    def on_change(self, ipc, e):
        self.build()
        self.notify_observers()

    def build(self):
        name = self.conn.get_tree().find_focused().name
        self.title = (name[:MAX_TITLE_LEN] + (
            u'â€¦' if len(name) > MAX_TITLE_LEN else ''
        )).encode(ENCODING)
        logger.debug('built win: %s' % self.title)

    def query(self):
        return self.title

class Bar:
    def __init__(self):
        i3_conn = i3ipc.Connection()

        self.datetime_updater = DatetimeUpdater(MIN_INTERVAL, [self])
        self.workspace_updater = WorkspaceUpdater(i3_conn, [self])
        self.window_updater = WindowUpdater(i3_conn, [self])

        self.threads = [
            Thread(target=self.datetime_updater.main),
            Thread(target=i3_conn.main),
        ]

    def start(self):
        for thread in self.threads:
            thread.daemon = True
            thread.start()

        self.output()

    def notify(self):
        self.output()

    def output(self):
        bar = S_TRANSPARENT

        window_update = self.window_updater.query()
        if window_update:
            bar += '%{l}' + S_NORMAL + '  ' + \
                window_update + '  ' + S_TRANSPARENT

        workspace_update = self.workspace_updater.query()
        if workspace_update:
            bar += '%{c}' + S_NORMAL + '  ' + \
                workspace_update + '  ' + S_TRANSPARENT

        datetime_update = self.datetime_updater.query()
        if datetime_update:
            bar += '%{r}' + S_NORMAL + '  ' + \
                datetime_update + '  ' + S_TRANSPARENT

        print(bar)
        logger.debug('emit: %s / %s' % (window_update, workspace_update))

        # Need this to fix buffering problem
        stdout.flush()


if __name__ == '__main__':
    # Set up logging
    ch = logging.StreamHandler(stderr)
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(ColoredFormatter(
        '[%(asctime)s] %(log_color)s%(message)s'))
    logger.addHandler(ch)

    Bar().start()
    try:
        while True:
            sleep(1)
    except KeyboardInterrupt:
        exit()

